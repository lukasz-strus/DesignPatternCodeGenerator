# DesignPatternCodeGenerator

## How to start using the library?
Edit your project and add the following, replacing the project path with the one from the .NET Standard project you created above:
```
  <ItemGroup>
	<ProjectReference Include="..\PathTo\DesignPatternCodeGenerator.csproj"
					  OutputItemType="Analyzer"
					  ReferenceOutputAssembly="true" />
    <ProjectReference Include="..\PathTo\DesignPatternCodeGenerator.csproj" />
  </ItemGroup>
```

The generated files can be seen in the project tree: 

Dependencies -> Analyzers -> 

![image](https://user-images.githubusercontent.com/61932823/202016757-a77d9caa-4e74-4714-8609-faaf1ae899f6.png)

## Factory
The factory pattern is generated based on three attributes:
- [Factory] - this attribute should be applied to the main interface,
- [Parameter] - this attribute should be applied to the property that is to be provided when creating individual objects,
- [FactoryChild] - this attribute should be applied to the class that implements the main interface.

### Example:
```csharp
[Factory]
public interface ICar
{
    [Parameter]
    public string Name { get; set; }        
    public int HorsePower { get; set; }

}

[FactoryChild]
class Bmw : ICar
{
    public string Name { get; set; }
    public int HorsePower { get; set; }

    public Bmw(string name, int horsePower)
    {
        Name = name;
        HorsePower = horsePower;
    }
}

[FactoryChild]
partial class Audi : ICar
{
    public string Name { get; set; }
    public int HorsePower { get; set; }

    public Audi(string name, int horsePower)
    {
        Name = name;
        HorsePower = horsePower;
    }
}
```

With this code, the generator will generate a Factory, which consists of a factory interface, a factory class, and an enumeration type.

```csharp
// <auto-generated/>
using DesignPatternCodeGenerator.Attributes;
using DesignPatternCodeGenerator.Attributes.Factory;

namespace Samples.Factory
{
    public interface ICarFactory
    {
        public ICar Create(CarFactoryType type,string Name);
    }
}
```

```csharp
// <auto-generated/>
using DesignPatternCodeGenerator.Attributes;
using DesignPatternCodeGenerator.Attributes.Factory;

namespace Samples.Factory
{
    public class CarFactory: ICarFactory
    {
        private readonly int _horsepower;
        
        public CarFactory(int HorsePower)
        {
            _horsepower = HorsePower;
        }
        
        public ICar Create(CarFactoryType type,string Name)
        {
          switch (type)
          {
              case CarFactoryType.Bmw :
                  return new Bmw(Name, _horsepower);
               case CarFactoryType.Audi :
                  return new Audi(Name, _horsepower);
               default :
                  throw new Exception($"Type {type} is not handled");
            }    
        }
    }
}
```

```csharp
// <auto-generated/>
using DesignPatternCodeGenerator.Attributes;
using DesignPatternCodeGenerator.Attributes.Factory;

namespace Samples.Factory
{
    public enum CarFactoryType
    {
        Bmw,
        Audi,
    }
}
```
##
## Singleton
The singleton pattern is generated based on only one attribute:
- [Singleton] - this attribute should be applied to the class that is about to become a singleton. The class must be a partial class.



