# DesignPatternCodeGenerator
The library is used to generate the code of typical design patterns in C #, based on the capabilities of the .NET Compiler Platform SDK (Roslyn APIs).
More information about Roslyn APIs: https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/ 

## Instalation

Install the [DesignPatternCodeGenerator NuGet Package](https://www.nuget.org/packages/DesignPatternCodeGenerator).

### Package Manager Console
```
Install-Package DesignPatternCodeGenerator
```

### .NET Core CLI

```
dotnet add package DesignPatternCodeGenerator
```

## Usage

The generated files can be seen in the project tree: 

Dependencies -> Analyzers -> 

![image](https://user-images.githubusercontent.com/61932823/202016757-a77d9caa-4e74-4714-8609-faaf1ae899f6.png)

## Examples

### Container IoC
The container IoC is genereted based on one attribute:
- [Container("ContainerName", ObjectLifeTime, new string[] { "ExcludedInterface1", "ExcludedInterface2" })]

or
- [Container("ContainerName", ObjectLifeTime)]

```csharp
using DesignPatternCodeGenerator.Attributes.ContainerIoC;

namespace Samples.ContainerIoC;

interface IViewModel1
{
}

interface IViewModel2
{
}

interface IViewModel3 : IViewModel2
{
}

interface IViewModel4
{
}

[Container("AddViewModels", ObjectLifeTime.Singleton, new string[] { "IViewModel4" })]
public class MainViewModel : IViewModel1, IViewModel3, IViewModel4, IDisposable
{
    public void Dispose()
    {
    }
}

[Container("AddViewModels", ObjectLifeTime.Transient)]
public class ViewModel : IViewModel1
{
}

[Container("AddViewModels", ObjectLifeTime.Scoped, new string[] { "IViewModel4", "IViewModel1" })]
public class MainViewModelExtension : MainViewModel
{
}
```
Using the code above, the generator will generate a container.

```csharp
// <auto-generated/>
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using DesignPatternCodeGenerator.Attributes.ContainerIoC;

namespace Samples.ContainerIoC
{
    public static class AddViewModelsHostBuildersExtension
    {
        public static IServiceCollection AddViewModels(this IServiceCollection services)
        {
	    services.AddSingleton<IViewModel1, MainViewModel>();
	    services.AddSingleton<IViewModel3, MainViewModel>();
	    services.AddSingleton<IViewModel2, MainViewModel>();
	    services.AddTransient<IViewModel1, ViewModel>();
	    services.AddScoped<IViewModel3, MainViewModelExtension>();
	    services.AddScoped<IViewModel2, MainViewModelExtension>();
            
            return services;
        }
    }
}
```

### Facade
The facade pattern is genereted based on three attributes:
- [FacadeMethod("FacadeMethodName")] - this attribute should be applied to the method that is about to become a facade method,
- [FacadeMainParameter("FacadeMethodParameter")] - this attribute should be applied to the facade method parameter,
- [FacadeParameter("ClassName.MethodName")] - this parameter should be applied to the parameter, and in the constructor it takes the method path.

```csharp
using DesignPatternCodeGenerator.Attributes.Facade;

namespace Samples.Facade;

public class DependencyScanner
{
    [FacadeMethod("Scan")]
    public IEnumerable<string> DependencyScan([FacadeMainParameter("githubUrl")]string githubUrl)
    {
        Console.WriteLine("Dependency Scan");

        return new List<string>() { "Dependency Error1" };
    }
}

public class QualityScanner
{
    [FacadeMethod("Scan")]
    public IEnumerable<string> QualityScan([FacadeMainParameter("githubUrl")] string githubUrl)
    {
        Console.WriteLine("Quality scan");

        return new List<string>() { "Error1", "Error2" };
    }
}

public class SecurityScanner
{
    [FacadeMethod("Scan")]
    public IEnumerable<string> SecurityScan([FacadeMainParameter("githubUrl")] string githubUrl)
    {
        Console.WriteLine("Security scan");

        return new List<string>() { "Security Error1" };
    }
}

public class ReportGenerator
{
    [FacadeMethod("Scan")]
    public void GenerateReport(
        [FacadeParameter("QualityScanner.QualityScan")] IEnumerable<string> qualityScanErrors,
        [FacadeParameter("SecurityScanner.SecurityScan")] IEnumerable<string> securityScanErrors,
        [FacadeParameter("DependencyScanner.DependencyScan")] IEnumerable<string> dependencyScanErrors)
    {
        Console.WriteLine("Quality Scan Errors:");
        Console.WriteLine(string.Join(", ", qualityScanErrors));

        Console.WriteLine("Security Scan Errors:");
        Console.WriteLine(string.Join(", ", securityScanErrors));

        Console.WriteLine("Dependency Scan Errors:");
        Console.WriteLine(string.Join(", ", dependencyScanErrors));
    }
}
```
Using the code above, the generator will generate a facade.

```csharp
// <auto-generated/>
using DesignPatternCodeGenerator.Attributes.Facade;

namespace Samples.Facade
{
    public class ScanFacade
    {
        private QualityScanner _qualityScanner = new QualityScanner();
	private SecurityScanner _securityScanner = new SecurityScanner();
	private DependencyScanner _dependencyScanner = new DependencyScanner();
	private ReportGenerator _reportGenerator = new ReportGenerator();

        public void Scan(string githubUrl)
        {
            var qualityScannerQualityScan = _qualityScanner.QualityScan(githubUrl);
	    var securityScannerSecurityScan = _securityScanner.SecurityScan(githubUrl);
	    var dependencyScannerDependencyScan = _dependencyScanner.DependencyScan(githubUrl);
	    
	    _reportGenerator.GenerateReport(qualityScannerQualityScan, securityScannerSecurityScan, dependencyScannerDependencyScan);
        }
    }
}
```

### Prototype
The prototype pattern is genereted based on one attribute:
- [Prototype] - this attribute should be applied to the class that is about to become a prototype. The class must be a partial class.

```csharp
using DesignPatternCodeGenerator.Attributes.Prototype;

namespace Samples.Prototype;

[Prototype]
public partial class Person
{
    public string? Name { get; set; }
    public string? LastName { get; set; }
    public Address? PersonAddress { get; set; }
    public Contacts? PersonContacts { get; set; }
}

public class Address
{
    public string? HouseNumber { get; set; }
    public string? Street { get; set; }
    public string? City { get; set; }
}

public class Contacts
{
    public string? PhoneNumber { get; set; }
    public string? Email { get; set; }
}
```
Using the code above, the generator will generate a partial class with an implemented prototype with the ShallowCopy() and DeepCopy() methods.

```csharp
// <auto-generated/>
using DesignPatternCodeGenerator.Attributes.Prototype;

namespace Samples.Prototype
{
    public partial class Person
    {
        public Person ShallowCopy()
        {
            return (Person)this.MemberwiseClone();
        }

        public Person DeepCopy()
        {
            Person clone = (Person)this.MemberwiseClone();

            clone.PersonAddress = new Address()
            {
	    	HouseNumber = PersonAddress.HouseNumber,
		Street = PersonAddress.Street,
		City = PersonAddress.City
            };

	    clone.PersonContacts = new Contacts()
            {
	    	PhoneNumber = PersonContacts.PhoneNumber,
		Email = PersonContacts.Email
            };

            return clone;
        }
    }
}
```

### AbstractFactory
The abstract factory pattern is generated based on two attributes:
- [AbstractFactory("MainInterfaceName")] - this attribute should be appiled to interface,
- [AbstractFactoryClass("FactoryClassName")] - this attribute should be appiled to class.

```csharp
using DesignPatternCodeGenerator.Attributes.AbstractFactory;

namespace Samples.AbstractFactory;

[AbstractFactory("UIElement")]
public interface IButton
{
    void Render();
    void HandleClick();
}

[AbstractFactoryClass("Windows")]
public class WindowsButton : IButton
{
    public void HandleClick()
    {
        Console.WriteLine("Handle windows click event");
    }

    public void Render()
    {
        Console.WriteLine("Render windows button");
    }
}

[AbstractFactoryClass("Mac")]
public class MacButton : IButton
{
    public void HandleClick()
    {
        Console.WriteLine("Handle mac click event");
    }

    public void Render()
    {
        Console.WriteLine("Render mac button");
    }
}
```

```csharp
using DesignPatternCodeGenerator.Attributes.AbstractFactory;

namespace Samples.AbstractFactory;

[AbstractFactory("UIElement")]
public interface ITextBox
{
    void Render();
    void HandleInput();
}

[AbstractFactoryClass("Windows")]
public class WindowsTextBox : ITextBox
{
    public void HandleInput()
    {
        Console.WriteLine("Handle windows text input");
    }

    public void Render()
    {
        Console.WriteLine("Render windows textbox");
    }
}

[AbstractFactoryClass("Mac")]
public class MacTextBox : ITextBox
{
    public void HandleInput()
    {
        Console.WriteLine("Handle mac text input");
    }

    public void Render()
    {
        Console.WriteLine("Render mac textbox");
    }
}
```
Using the code above, the generator will generate an abstract factory which consists of a main factory interface and factory classes.

```csharp
// <auto-generated/>
using DesignPatternCodeGenerator.Attributes.AbstractFactory;

namespace Samples.AbstractFactory
{
    public interface IUIElementFactory
    {
    	ITextBox CreateTextBox();
	IButton CreateButton();
    }
}
```
```csharp
// <auto-generated/>
using DesignPatternCodeGenerator.Attributes.AbstractFactory;

namespace Samples.AbstractFactory
{
    public class WindowsFactory : IUIElementFactory
    {
        
        public ITextBox CreateTextBox()
        {
            return new WindowsTextBox();
        }

        public IButton CreateButton()
        {
            return new WindowsButton();
        }
    }
}
```
```csharp
// <auto-generated/>
using DesignPatternCodeGenerator.Attributes.AbstractFactory;

namespace Samples.AbstractFactory
{
    public class MacFactory : IUIElementFactory
    {
        
        public ITextBox CreateTextBox()
        {
            return new MacTextBox();
        }

        public IButton CreateButton()
        {
            return new MacButton();
        }
    }
}
```


### Factory
The factory pattern is generated based on three attributes:
- [Factory] - this attribute should be applied to the main interface,
- [Parameter] - this attribute should be applied to the property that is to be provided when creating individual objects,
- [FactoryProduct] - this attribute should be applied to the class that implements the main interface.

```csharp
using DesignPatternCodeGenerator.Attributes;
using DesignPatternCodeGenerator.Attributes.Factory;

namespace Samples.Factory;
[Factory]
public interface ICar
{
    [Parameter]
    public string Name { get; set; }        
    public int HorsePower { get; set; }

}

[FactoryProduct]
class Bmw : ICar
{
    public string Name { get; set; }
    public int HorsePower { get; set; }

    public Bmw(string name, int horsePower)
    {
        Name = name;
        HorsePower = horsePower;
    }
}

[FactoryProduct]
partial class Audi : ICar
{
    public string Name { get; set; }
    public int HorsePower { get; set; }

    public Audi(string name, int horsePower)
    {
        Name = name;
        HorsePower = horsePower;
    }
}
```

Using the code above, the generator will generate a factory which consists of a factory interface, a factory class, and an enum type.

```csharp
// <auto-generated/>
using DesignPatternCodeGenerator.Attributes;
using DesignPatternCodeGenerator.Attributes.Factory;

namespace Samples.Factory
{
    public interface ICarFactory
    {
        public ICar Create(CarFactoryType type,string Name);
    }
}
```

```csharp
// <auto-generated/>
using DesignPatternCodeGenerator.Attributes;
using DesignPatternCodeGenerator.Attributes.Factory;

namespace Samples.Factory
{
    public class CarFactory: ICarFactory
    {
        private readonly int _horsepower;
        
        public CarFactory(int HorsePower)
        {
            _horsepower = HorsePower;
        }
        
        public ICar Create(CarFactoryType type,string Name)
        {
          switch (type)
          {
              case CarFactoryType.Bmw :
                  return new Bmw(Name, _horsepower);
               case CarFactoryType.Audi :
                  return new Audi(Name, _horsepower);
               default :
                  throw new Exception($"Type {type} is not handled");
            }    
        }
    }
}
```

```csharp
// <auto-generated/>
using DesignPatternCodeGenerator.Attributes;
using DesignPatternCodeGenerator.Attributes.Factory;

namespace Samples.Factory
{
    public enum CarFactoryType
    {
        Bmw,
        Audi,
    }
}
```

### Null Object
The null object pattern is generated based on only one attribute:
- [NullObject] - this attribute should be applied to the interface.

```csharp
[NullObject]
public interface ILog
{
    public int Id { get; }
    public string Login(string username, string password);
    public void Info(string message);
    public void Warn(string message);
}
```
Using the code above, the generator will generate a class with the null object implemented.

```csharp
// <auto-generated/>
using DesignPatternCodeGenerator.Attributes.NullObject;

namespace Samples.NullObject
{
    public class LogNullObject : ILog
    {
    	public int Id { get; }

	public void Info(string message) { }
	public void Warn(string message) { }
	public string Login(string username, string password) 
        {
	    return default(string);
        }
    }
}
```

### Singleton
The singleton pattern is generated based on only one attribute:
- [Singleton] - this attribute should be applied to the class that is about to become a singleton. The class must be a partial class.

```csharp
[Singleton]
public partial class Configuration
{
    public string SomeProperty { get; set; }
}
```
Using the code above, the generator will generate a partial class with the singleton implemented.

```csharp
// <auto-generated/>
using DesignPatternCodeGenerator.Attributes.Singleton;

namespace Samples.Singleton
{
    public partial class Configuration
    {
    	private static Configuration _instance = null;
	private static object obj = new object();
	
	private Configuration() { }
	
	public static Configuration GetInstance()
	{
            lock(obj)
            {
                if (_instance == null)
                {
                    _instance = new Configuration();
                }
            }

        return _instance;
        }
    }
}
```

