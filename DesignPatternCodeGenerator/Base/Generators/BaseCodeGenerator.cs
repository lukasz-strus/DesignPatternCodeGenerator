using DesignPatternCodeGenerator.Base.Enums;
using DesignPatternCodeGenerator.Base.Models;
using Microsoft.CodeAnalysis;
using System.Linq;

namespace DesignPatternCodeGenerator.Base.Generators
{
    internal class BaseCodeGenerator
    {
        private readonly SyntaxTokens _syntaxTokens;
        private readonly SyntaxTokensConfigurations _configurations;

        internal BaseCodeGenerator(SyntaxTokens syntaxTokens, SyntaxTokensConfigurations configurations)
        {
            _syntaxTokens = syntaxTokens;
            _configurations = configurations;
        }

        internal string GenerateUsingsAndNamespace()
            => $"// <auto-generated/>\r\n{GenerateUsings()}\r\n\r\nnamespace {_syntaxTokens.Namespace}";

        private string GenerateUsings() => $@"{string.Join("\n", _syntaxTokens.Usings.Select(x => $"using {x};"))}";

        internal string GenerateDeclaration(CodeType codeType)
        {
            switch (codeType)
            {
                case CodeType.Interface:
                    return GenerateInterfaceDeclaration();
                case CodeType.Class:
                    return GenerateClassDeclaration();
                case CodeType.Enum:
                    return GenerateEnumDeclaration();
                default:
                    return "";
            }
        }

        private string GenerateInterfaceDeclaration() 
            => $"{_syntaxTokens.Accessibility} interface {_syntaxTokens.InterfaceName}";

        private string GenerateClassDeclaration()
            => _configurations.IsMainAttributeOnInterface 
            ? $"{_syntaxTokens.Accessibility}{_syntaxTokens.AdditionalClassToken} class {_syntaxTokens.ClassName}: {_syntaxTokens.InterfaceName}"
            : $"{_syntaxTokens.Accessibility}{_syntaxTokens.AdditionalClassToken} class {_syntaxTokens.ClassName}";

        private string GenerateEnumDeclaration() 
            => $"{_syntaxTokens.Accessibility} enum {_syntaxTokens.ClassName}Type";
    }
}
