using DesignPatternCodeGenerator.Base.Generators;
using DesignPatternCodeGenerator.Base.Models;
using DesignPatternCodeGenerator.Factory;
using DesignPatternCodeGenerator.Tests.Helpers;
using FluentAssertions;
using Xunit;

namespace DesignPatternCodeGenerator.Tests.Factory;

public class FactoryChildGeneratorTests
{
    [Theory]
    [InlineData(FACTORY_COMPILATION_SOURCE, FACTORY_ENUM_SOURCE)]
    internal void GenerateEnum_ForValidInput_ReturnCorrectEnum(string source, string expected)
    {
        var codeGenerator = new BaseCodeGenerator(_syntaxTokens, _configuration);
        var factoryChildGroups = GeneratorTestsHelper.GetClassGroups(source);

        var result = FactoryChildGenerator.GenerateEnum(codeGenerator, factoryChildGroups);

        result.RemoveWhitespace()
            .Should()
            .Be(expected.RemoveWhitespace());
    }

    private readonly SyntaxTokensConfigurations _configuration = new()
    {
        IsMainAttributeOnInterface = true,
        IsDesignPatternPostfix = true,
    };

    private readonly SyntaxTokens _syntaxTokens = new()
    {
        ClassName = "Test",
        InterfaceName = "ITest",
        Namespace = "Test.Test",
        Accessibility = "public",
        Usings = new List<string>() { "System" }
    };

    private const string FACTORY_COMPILATION_SOURCE =
    @"using DesignPatternCodeGenerator.Attributes.Factory;
using System;

namespace DesignPatternCodeGenerator.Tests.Data
{
    [Factory]
    public interface ITest { }

    [FactoryChild]
    public class Test1 : ITest { }

    [FactoryChild]
    public class Test2 : ITest { }

    [FactoryChild]
    public class Test3 : ITest { }
}";

    private const string FACTORY_ENUM_SOURCE =
    @"// <auto-generated/>
using System;

namespace Test.Test
{
    public enum TestType
    {
	    Test1,
        Test2,
        Test3,

    }
}";
}
