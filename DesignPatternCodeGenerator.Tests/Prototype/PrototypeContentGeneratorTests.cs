using DesignPatternCodeGenerator.Prototype;
using DesignPatternCodeGenerator.Tests.Helpers;
using FluentAssertions;
using Xunit;

namespace DesignPatternCodeGenerator.Tests.Prototype;

public class PrototypeContentGeneratorTests
{
    [Theory]
    [InlineData(PROTOTYPE_COMPILATION_SOURCE, EXPECTED_COMPILATION_SOURCE)]
    internal void GenerateClass_ForValidInputs_ReturnInterface(string inputSource, string expectedSource)
    {
        var classGroup = GeneratorTestsHelper.GetClassGroup(inputSource);
        var allClassGroup = GeneratorTestsHelper.GetClassGroups(inputSource);

        var result = PrototypeContentGenerator.GenerateClass(classGroup, allClassGroup);

        result.RemoveWhitespace().Should().Be(expectedSource.RemoveWhitespace());
    }

    private const string PROTOTYPE_COMPILATION_SOURCE =
@"using DesignPatternCodeGenerator.Attributes.Prototype;

namespace Test.Test
{
    [Prototype]
    public partial class Person 
    { 
        public string Name {get; set;}
        
        public Address PersonAddress {get; set;}
    }

    public class Address
    {
        public string City { get; set; }
        public string Street { get; set; }
    }
}";

    private const string EXPECTED_COMPILATION_SOURCE =
@"// <auto-generated/>
using DesignPatternCodeGenerator.Attributes.Prototype;

namespace Test.Test
{    
    public partial class Person 
    { 
        public Person ShallowCopy()
        {            
            return (Person)this.MemberwiseClone();
        }

        public Person DeepCopy()
        {
            Person clone = (Person)this.MemberwiseClone();
            
            clone.PersonAddress = new Address()
            {
                City = PersonAddress.City,
                Street = PersonAddress.Street
            };

            return clone;
        }
    }
}";
}
